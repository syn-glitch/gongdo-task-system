# 🤖 AI 에이전트 간 문서 교환 자동화 아이디어 (자비스 제안)
**작성일**: 2026-02-27
**작성자**: 자비스 (PO/개발 에이전트)

팀장님께서 현재 겪고 계시는 "자비스(PO) → 파일 저장 → 팀장님 복사 → 김감사(QA) 프롬프트 창에 붙여넣기 → 김감사 파일 생성 → 팀장님 복사 → 자비스 프롬프트 창에 붙여넣기" 와 같은 번거로운 단계를 자동화하는 효율적인 방법들을 고민해보았습니다.

제가 Google Workspace 생태계(GAS+Sheets+Docs) 위에서 동작하는 '가상 팀'임을 감안할 때, 가장 적은 비용으로 즉시 적용 가능한 3가지 워크플로우를 제안합니다.

---

## 💡 제안 1. "전용 슬랙 채널(ex: #agent-sync)을 통한 Webhook 핑퐁" (가장 추천)
현재 이미 슬랙 명령어 봇(/주디)이 연동되어 있으니, 이 인프라를 확장하여 에이전트들끼리 대화하는 전용 슬랙 채널을 신설하는 구조입니다.

**동작 방식:**
1. 자비스가 구현을 마친 뒤 `.md` 문서를 특정 구글 드라이브 폴더에 저장합니다.
2. 이와 동시에 자비스(GAS)는 슬랙 `#agent-sync` (비공개 채널)로 알람을 쏩니다.
   - *"@김감사QA, `2026-02-27_slack_modal_v3.gs` 구현이 끝났으니 QA 부탁합니다. 링크: [드라이브 링크]"*
3. 해당 슬랙 멘션 이벤트를 감지하는 다른 에이전트(김감사)가 웹훅을 통해 문서를 읽어옵니다.
4. 김감사가 QA 문서를 다시 구글 드라이브에 저장하고, 자비스를 멘션합니다.
   - *"@자비스PO, QA 완료. 리뷰 결과 3개의 에러 발견. 수정 바랍니다. 링크: [리뷰 링크]"*
5. 핑퐁이 완전히 끝나서 배포만 남았을 때 비로소 **팀장님(사용자)을 멘션하여 "최종 컴파일 완료되었습니다. 구글 스크립트에 덮어써 주세요"** 라고 알람만 보냅니다.

**장점**: 에이전트 간의 티키타카(로그)를 팀장님이 슬랙 채널에서 원할 때 관전(?)할 수 있으며, 팀장님의 물리적 복원 복사가 완전히 사라집니다.

---

## 💡 제안 2. "구글 시트 기반 칸반보드를 메인 큐(Queue)로 사용"
현재 개발 중인 '주디 워크스페이스(웹 앱)'의 칸반 보드 기술을 역이용하여, 에이전트 전용 작업 대기열(Task Queue) 시트를 하나 만드는 것입니다.

**동작 방식:**
1. [PO_Agent_Tasks] 시트에 팀장님이 "슬랙 모달 에러 고쳐줘" 라벨을 달아 둡니다.
2. 자비스가 GAS 시간 기반 트리거(ex: 1분)로 해당 시트를 읽고 작업을 시작합니다. 완료되면 상태를 "QA_Review_Ready"로 바꾸고 결과 `.md` 내용을 시트 특정 셀(혹은 구글 독스 링크)에 넣습니다.
3. 김감사 에이전트 역시 1분마다 시트를 읽어 "QA_Review_Ready" 상태인 행을 찾아 리뷰를 진행하고 상태를 "Dev_Fix_Required" 혹은 "Done"으로 바꿉니다.
4. 핑퐁 결과 "Done" 상태가 되면, GAS가 팀장님께 최종 팝업(혹은 이메일/슬랙)을 넘깁니다.

**장점**: 워크플로우가 데이터베이스(엑셀)로 관리되니 히스토리 추적이 완벽하며, 현재 공도 업무 관리의 코어를 그대로 활용할 수 있습니다.

---

## 💡 제안 3. "단일 에이전트 내 다중 페르소나 체인 (LangChain Style)"
조금 더 깊은 개발이 필요하지만, 현재 팀장님이 이용하시는 채팅 인터페이스 자체를 하나로 통합하는 방법입니다. 어찌보면 외부 시스템(Slack이나 Sheets)의 에이전트를 두 명 두는 것이 아니라, "메인 매니저 챗봇" 하나에게 이 권한을 위임합니다.

**동작 방식:**
1. 팀장님: "이거 고쳐줘"
2. 메인 에이전트(자비스) 파이프라인 시작:
   `[내부 구동]` 자비스가 코드 작성 → 스스로 내부 메모리에서 김감사 프롬프트를 호출하여 자체 검증(`self-reflection`) 시행 → 반려되면 스스로 다시 수정 → 합격할 때까지 백그라운드 반복.
3. 메인 에이전트: "팀장님, 제가 작성하고, 제 내부망의 가상 QA를 거쳐 3번 수정한 최종 결과입니다."

**장점**: 서버 인프라 조작 없이, 프롬프트 엔지니어링이나 로컬 LLM 에이전트 도구(예: AutoGen, Cursor AI 기능, Claude Computer Use 등) 환경 안에서 스레드(Thread)를 엮어서 해결 가능합니다.

---

### 자비스의 의견
가장 구현하기 현실적이고, 팀장님이 지금처럼 '파일을 확인하고 배포하는' 통제권을 잃지 않으면서도 **가장 확실한 피드백을 주는 방식은 [제안 2]의 "구글 시트를 기반으로 한 에이전트 상태 변경(Kanban Queue 방식)"** 입니다.

제가(자비스) 현재 구글 시트를 DB로 삼는 데 익숙하고, 에이전트들끼리는 각자의 채팅창에서 하나의 구글 시트를 주기적으로 참조(`view_file` 또는 `UrlFetchApp`)하도록 프롬프트 지시를 내려놓기만 하면 자연스러운 파이프라인이 생성됩니다.

어떤 방향성이 팀장님의 그림에 가장 맞으시나요?
